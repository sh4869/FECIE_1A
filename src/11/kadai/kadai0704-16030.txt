
# kadai11-1


## ソースコード


```c

#include <stdio.h>
#include "PLIB.h"

BSTnode *head;

void printtree(BSTnode *p){
  if(p == NULL) return;
  printf("%2d(%p) ",p->key,p);
  if(p->lson != NULL){
    printf("(%2d(%p)) ",(p->lson)->key,p->lson);
  } else {
    printf("(0(%p)) ",p->lson);
  }
  if(p->rson != NULL){
    printf("(%2d(%p)) \n",(p->rson)->key,p->rson);
  } else {
    printf("(0(%p))\n ",p->rson);
  }
  if(p->lson != NULL){
    printtree(p->lson);
  }
  if(p->rson != NULL){
    printtree(p->rson);
  }
}
int main(void){
  BSTnode *p57,*p22,*p80,*p14,*p34,*p71;
  printf("/**(Binary search tree: Page63 Figure1) **\n");
  head = p57 = node(57);
  p22 = node(22);
  p80 = node(80);
  tree(p57,p22,p80);
  p14 = node(14);
  p34 = node(34);
  tree(p22,p14,p34);
  p71 = node(71);
  tree(p80,p71,node(87));
  tree(p14,node(4),node(17));
  tree(p71,node(59),NULL);
  printf("**** printtree *** \n");
  printtree(head);
  printf("*/\n");
}

```

## 出力


```

/**(Binary search tree: Page63 Figure1) **
57 (0000000000762430), (22 (0000000000762450),80 (0000000000762470))
22 (0000000000762450), (14 (0000000000762490),34 (00000000007624B0))
80 (0000000000762470), (71 (00000000007624D0),87 (00000000007624F0))
14 (0000000000762490), ( 4 (0000000000762530),17 (0000000000762510))
71 (00000000007624D0), (59 (0000000000762550), 0 (0000000000000000))
**** printtree *** 
57(0000000000762430) (22(0000000000762450)) (80(0000000000762470)) 
22(0000000000762450) (14(0000000000762490)) (34(00000000007624B0)) 
14(0000000000762490) ( 4(0000000000762530)) (17(0000000000762510)) 
 4(0000000000762530) (0(0000000000000000)) (0(0000000000000000))
 17(0000000000762510) (0(0000000000000000)) (0(0000000000000000))
 34(00000000007624B0) (0(0000000000000000)) (0(0000000000000000))
 80(0000000000762470) (71(00000000007624D0)) (87(00000000007624F0)) 
71(00000000007624D0) (59(0000000000762550)) (0(0000000000000000))
 59(0000000000762550) (0(0000000000000000)) (0(0000000000000000))
 87(00000000007624F0) (0(0000000000000000)) (0(0000000000000000))
 */



```


# kadai11-2


## ソースコード


```c

#include <stdio.h>
#include "PLIB.h"

BSTnode *node(int);
BSTnode *head;
int insert1(BSTnode *,int );

int main(void){
  BSTnode *p57,*p22,*p80,*p14,*p34,*p71;
  int data,rc;
  printf("/*** アルゴリズム4.1 **\n");
  head = p57 = node(57);
  p22 = node(22);
  p80 = node(80);
  tree(p57,p22,p80);
  p14 = node(14);
  p34 = node(34);
  tree(p22,p14,p34);
  p71 = node(71);
  tree(p80,p71,node(87));
  tree(p14,node(4),node(17));
  tree(p71,node(59),NULL);
  while(1){
    printf("正の整数を入力してください(-1=>print,0=>終了)");
    scanf("%d",&data);
    if(data == 0){
      break;
    } else if(data < 0){
      printf("(headの内容=%p)\n",head);
      printtree(head);
    } else {
      rc = insert1(head,data);
      if(rc == 0){
        printf("key=%dを追加しました\n",data);
      } else {
        printf("key = %d は既に存在します\n",data);
      }
    }
  }
}

int insert1(BSTnode *head,int x){
  BSTnode *v,*up,*nr;
  v = head;
  while(v != NULL){
    up = v;
    if(x < v->key){
      v = v->lson;
    } else if(x > v->key){
      v = v->rson;
    } else {
      return 1;
    }
  }
  nr = node(x);
  printf("%2d(%p) ",x,nr);
  if(x < up->key){
    up->lson = nr;
  } else {
    up->rson = nr;
  }
  return 0;
}

```

## 出力


```

/*** アルゴリズム4.1 **
57 (00000000009B2430), (22 (00000000009B2450),80 (00000000009B2470))
22 (00000000009B2450), (14 (00000000009B2490),34 (00000000009B24B0))
80 (00000000009B2470), (71 (00000000009B24D0),87 (00000000009B24F0))
14 (00000000009B2490), ( 4 (00000000009B2530),17 (00000000009B2510))
71 (00000000009B24D0), (59 (00000000009B2550), 0 (0000000000000000))
正の整数を入力してください(-1=>print,0=>終了)10(00000000009B2570) key=10を追加しました
正の整数を入力してください(-1=>print,0=>終了)20(00000000009B2590) key=20を追加しました
正の整数を入力してください(-1=>print,0=>終了)(headの内容=00000000009B2430)
57(00000000009B2430) (22(00000000009B2450)) (80(00000000009B2470)) 
22(00000000009B2450) (14(00000000009B2490)) (34(00000000009B24B0)) 
14(00000000009B2490) ( 4(00000000009B2530)) (17(00000000009B2510)) 
 4(00000000009B2530) (0(0000000000000000)) (10(00000000009B2570)) 
10(00000000009B2570) (0(0000000000000000)) (0(0000000000000000))
 17(00000000009B2510) (0(0000000000000000)) (20(00000000009B2590)) 
20(00000000009B2590) (0(0000000000000000)) (0(0000000000000000))
 34(00000000009B24B0) (0(0000000000000000)) (0(0000000000000000))
 80(00000000009B2470) (71(00000000009B24D0)) (87(00000000009B24F0)) 
71(00000000009B24D0) (59(00000000009B2550)) (0(0000000000000000))
 59(00000000009B2550) (0(0000000000000000)) (0(0000000000000000))
 87(00000000009B24F0) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)30(00000000009B25B0) key=30を追加しました
正の整数を入力してください(-1=>print,0=>終了)key = 20 は既に存在します
正の整数を入力してください(-1=>print,0=>終了)(headの内容=00000000009B2430)
57(00000000009B2430) (22(00000000009B2450)) (80(00000000009B2470)) 
22(00000000009B2450) (14(00000000009B2490)) (34(00000000009B24B0)) 
14(00000000009B2490) ( 4(00000000009B2530)) (17(00000000009B2510)) 
 4(00000000009B2530) (0(0000000000000000)) (10(00000000009B2570)) 
10(00000000009B2570) (0(0000000000000000)) (0(0000000000000000))
 17(00000000009B2510) (0(0000000000000000)) (20(00000000009B2590)) 
20(00000000009B2590) (0(0000000000000000)) (0(0000000000000000))
 34(00000000009B24B0) (30(00000000009B25B0)) (0(0000000000000000))
 30(00000000009B25B0) (0(0000000000000000)) (0(0000000000000000))
 80(00000000009B2470) (71(00000000009B24D0)) (87(00000000009B24F0)) 
71(00000000009B24D0) (59(00000000009B2550)) (0(0000000000000000))
 59(00000000009B2550) (0(0000000000000000)) (0(0000000000000000))
 87(00000000009B24F0) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)key = 20 は既に存在します
正の整数を入力してください(-1=>print,0=>終了)key = 30 は既に存在します
正の整数を入力してください(-1=>print,0=>終了)40(00000000009B25D0) key=40を追加しました
正の整数を入力してください(-1=>print,0=>終了)50(00000000009B7990) key=50を追加しました
正の整数を入力してください(-1=>print,0=>終了)


```


# kadai11-3


## ソースコード


```c

#include <stdio.h>
#include "PLIB.h"

BSTnode *node(int);
BSTnode *head;
int insert1(BSTnode *,int );

int main(void){
  BSTnode *p57,*p22,*p80,*p14,*p34,*p71;
  int data,rc;
  printf("/*** アルゴリズム4.1 **\n");
  head = p57 = node(57);
  p22 = node(22);
  p80 = node(80);
  tree(p57,p22,p80);
  p14 = node(14);
  p34 = node(34);
  tree(p22,p14,p34);
  p71 = node(71);
  tree(p80,p71,node(87));
  tree(p14,node(4),node(17));
  tree(p71,node(59),NULL);
  while(1){
    printf("正の整数を入力してください(-1=>print,0=>終了)");
    scanf("%d",&data);
    if(data == 0){
      break;
    } else if(data < 0){
      printf("(headの内容=%p)\n",head);
      printtree(head);
    } else {
      rc = insert1(head,data);
      if(rc == 0){
        printf("key=%dを追加しました\n",data);
      } else {
        printf("key = %d は既に存在します\n",data);
      }
    }
  }
}

int insert1(BSTnode *head,int x){
  BSTnode *v,*up,*nr;
  v = head;
  printf("Trace:");
  while(v != NULL){
    up = v;
    printf(" %d,",v->key);
    if(x < v->key){
      v = v->lson;
    } else if(x > v->key){
      v = v->rson;
    } else {
      return 1;
    }
  }
  printf("\n");
  nr = node(x);
  printf("%2d(%p) ",x,nr);
  if(x < up->key){
    up->lson = nr;
  } else {
    up->rson = nr;
  }
  return 0;
}

```

## 出力


```

/*** アルゴリズム4.1 **
57 (0000000000172430), (22 (0000000000172450),80 (0000000000172470))
22 (0000000000172450), (14 (0000000000172490),34 (00000000001724B0))
80 (0000000000172470), (71 (00000000001724D0),87 (00000000001724F0))
14 (0000000000172490), ( 4 (0000000000172530),17 (0000000000172510))
71 (00000000001724D0), (59 (0000000000172550), 0 (0000000000000000))
正の整数を入力してください(-1=>print,0=>終了)
Trace: 57, 22, 14, 17,
20(0000000000172570) key=20を追加しました
正の整数を入力してください(-1=>print,0=>終了)
Trace: 57, 22, 34,
30(0000000000172590) key=30を追加しました
正の整数を入力してください(-1=>print,0=>終了)
Trace: 57, 22, 34,
40(00000000001725B0) key=40を追加しました
正の整数を入力してください(-1=>print,0=>終了)
Trace: 57, 22, 14, 4,
12(00000000001725D0) key=12を追加しました
正の整数を入力してください(-1=>print,0=>終了)(headの内容=0000000000172430)
57(0000000000172430) (22(0000000000172450)) (80(0000000000172470)) 
22(0000000000172450) (14(0000000000172490)) (34(00000000001724B0)) 
14(0000000000172490) ( 4(0000000000172530)) (17(0000000000172510)) 
 4(0000000000172530) (0(0000000000000000)) (12(00000000001725D0)) 
12(00000000001725D0) (0(0000000000000000)) (0(0000000000000000))
 17(0000000000172510) (0(0000000000000000)) (20(0000000000172570)) 
20(0000000000172570) (0(0000000000000000)) (0(0000000000000000))
 34(00000000001724B0) (30(0000000000172590)) (40(00000000001725B0)) 
30(0000000000172590) (0(0000000000000000)) (0(0000000000000000))
 40(00000000001725B0) (0(0000000000000000)) (0(0000000000000000))
 80(0000000000172470) (71(00000000001724D0)) (87(00000000001724F0)) 
71(00000000001724D0) (59(0000000000172550)) (0(0000000000000000))
 59(0000000000172550) (0(0000000000000000)) (0(0000000000000000))
 87(00000000001724F0) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)


```


# kadai11-4


## ソースコード


```c

#include <stdio.h>
typedef struct LIST {
  int data;
  float x;
} LIST;

void swap_err(int,int);
void swap(int*,int*);
void swap_ptr(LIST**,LIST**);
int main(void){
  int aa=100,bb=200;
  LIST *h1,*h2,block1,block2;
  printf("/** 準備(ポインタの引数とSWAP)**\n");

  printf("(case-1) swap_err aa=%d bb=%d\n",aa,bb);
  swap_err(aa,bb);
  printf("after  swap_err aa=%d bb=%d\n",aa,bb);

  printf("(case-2) swap aa=%d bb=%d\n",aa,bb);
  swap(&aa,&bb);
  printf("after  swap aa=%d bb=%d\n",aa,bb);
  h1 = &block1;
  block1.data = 1111;
  block1.x = 11.1f;
  h2 = &block2;
  block2.data = 2222;
  block2.x = 22.2f;

  printf("(case-3)\n");
  printf("h1=%p,h1->data=%d,h1->x=%0.2f\n",h1,h1->data,h1->x);
  printf("h2=%p,h2->data=%d,h2->x=%0.2f\n",h2,h2->data,h2->x);
  swap_ptr(&h1,&h2);
  printf("after swap_ptr\n");
  printf("h1=%p,h1->data=%d,h1->x=%0.2f\n",h1,h1->data,h1->x);
  printf("h2=%p,h2->data=%d,h2->x=%0.2f\n",h2,h2->data,h2->x);
  printf("*/\n");
}

void swap_err(int a,int b){
  int t;
  t = a;
  a = b;
  b = t;
  printf("\n Inside swap_err a=%d,b=%d",a,b);
}

void swap(int *a,int *b){
  int t;
  t = *a;
  *a = *b;
  *b = t;
}

void swap_ptr(LIST **a,LIST **b){
  LIST *t;
  t = *a;
  *a = *b;
  *b = t;
}


```

## 出力


```

/** 準備(ポインタの引数とSWAP)**
(case-1) swap_err aa=100 bb=200

 Inside swap_err a=200,b=100after  swap_err aa=100 bb=200
(case-2) swap aa=100 bb=200
after  swap aa=200 bb=100
(case-3)
h1=000000000066FE30,h1->data=1111,h1->x=11.10
h2=000000000066FE20,h2->data=2222,h2->x=22.20
after swap_ptr
h1=000000000066FE20,h1->data=2222,h1->x=22.20
h2=000000000066FE30,h2->data=1111,h2->x=11.10
*/



```


# kadai11-5


## ソースコード


```c

#include <stdio.h>
#include "PLIB.h"

BSTnode *node(int);
BSTnode *head;
int insert2(BSTnode **,int);
int main(void){
  int data,rc;
  printf("/*** アルゴリズム4.1(挿入:head==NULLから開始可能) **\n");
  head = NULL;
  while(1){

    printf("正の整数を入力してください(-1=>print,0=>終了)");
    scanf("%d",&data);
    if(data == 0){
      break;
    } else if(data < 0){
      printf("(headの内容=%p)\n",head);
      printtree(head);
    } else {
      rc = insert2(&head,data);
      if(rc == 0){
        printf("key=%dを追加しました\n",data);
      } else {
        printf("key = %d は既に存在します\n",data);
      }
    }
  }
}

int insert2(BSTnode **head,int x){
  BSTnode *v,*up,*nr;
  if(*head==NULL){
    *head = node(x);
    return 0;
  }
  v = *head;
  while(v != NULL){
    up = v;
    if(x < v->key){
      v = v->lson;
    } else if(x > v->key){
      v = v->rson;
    } else {
      return 1;
    }
  }
  nr = node(x);
  printf("%2d(%p) ",x,nr);
  if(x < up->key){
    up->lson = nr;
  } else {
    up->rson = nr;
  }
  return 0;
}

```

## 出力


```

/*** アルゴリズム4.1(挿入:head==NULLから開始可能) **
正の整数を入力してください(-1=>print,0=>終了)
key=57を追加しました
正の整数を入力してください(-1=>print,0=>終了)
22(0000000000742450) 
key=22を追加しました
正の整数を入力してください(-1=>print,0=>終了)
80(0000000000742470) 
key=80を追加しました
正の整数を入力してください(-1=>print,0=>終了)
14(0000000000742490) 
key=14を追加しました
正の整数を入力してください(-1=>print,0=>終了)
34(00000000007424B0) 
key=34を追加しました
正の整数を入力してください(-1=>print,0=>終了)
71(00000000007424D0) 
key=71を追加しました
正の整数を入力してください(-1=>print,0=>終了)
87(00000000007424F0) 
key=87を追加しました
正の整数を入力してください(-1=>print,0=>終了)
(headの内容=0000000000742430)
57(0000000000742430) (22(0000000000742450)) (80(0000000000742470)) 
22(0000000000742450) (14(0000000000742490)) (34(00000000007424B0)) 
14(0000000000742490) (0(0000000000000000)) (0(0000000000000000))
 34(00000000007424B0) (0(0000000000000000)) (0(0000000000000000))
 80(0000000000742470) (71(00000000007424D0)) (87(00000000007424F0)) 
71(00000000007424D0) (0(0000000000000000)) (0(0000000000000000))
 87(00000000007424F0) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)


```


# kadai11-6


## ソースコード


```c

/** ソースコードは省略**/


```

## 出力


```


(1)
/*** アルゴリズム4.1(挿入:head==NULLから開始可能) **
正の整数を入力してください(-1=>print,0=>終了)
key=10を追加しました
正の整数を入力してください(-1=>print,0=>終了)
20(0000000000162450) key=20を追加しました
正の整数を入力してください(-1=>print,0=>終了)
30(0000000000162470) key=30を追加しました
正の整数を入力してください(-1=>print,0=>終了)
40(0000000000162490) key=40を追加しました
正の整数を入力してください(-1=>print,0=>終了)
(headの内容=0000000000162430)
10(0000000000162430) (0(0000000000000000)) (20(0000000000162450)) 
20(0000000000162450) (0(0000000000000000)) (30(0000000000162470)) 
30(0000000000162470) (0(0000000000000000)) (40(0000000000162490)) 
40(0000000000162490) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)
(2)
/*** アルゴリズム4.1(挿入:head==NULLから開始可能) **
正の整数を入力してください(-1=>print,0=>終了)
key=30を追加しました
正の整数を入力してください(-1=>print,0=>終了)
60(00000000001A2450) key=60を追加しました
正の整数を入力してください(-1=>print,0=>終了)
70(00000000001A2470) key=70を追加しました
正の整数を入力してください(-1=>print,0=>終了)
65(00000000001A2490) key=65を追加しました
正の整数を入力してください(-1=>print,0=>終了)
75(00000000001A24B0) key=75を追加しました
正の整数を入力してください(-1=>print,0=>終了)
20(00000000001A24D0) key=20を追加しました
正の整数を入力してください(-1=>print,0=>終了)
25(00000000001A24F0) key=25を追加しました
正の整数を入力してください(-1=>print,0=>終了)
15(00000000001A2510) key=15を追加しました
正の整数を入力してください(-1=>print,0=>終了)
(headの内容=00000000001A2430)
30(00000000001A2430) (20(00000000001A24D0)) (60(00000000001A2450)) 
20(00000000001A24D0) (15(00000000001A2510)) (25(00000000001A24F0)) 
15(00000000001A2510) (0(0000000000000000)) (0(0000000000000000))
 25(00000000001A24F0) (0(0000000000000000)) (0(0000000000000000))
 60(00000000001A2450) (0(0000000000000000)) (70(00000000001A2470)) 
70(00000000001A2470) (65(00000000001A2490)) (75(00000000001A24B0)) 
65(00000000001A2490) (0(0000000000000000)) (0(0000000000000000))
 75(00000000001A24B0) (0(0000000000000000)) (0(0000000000000000))
 正の整数を入力してください(-1=>print,0=>終了)


```

